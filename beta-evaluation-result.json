{
  "timestamp": "2025-06-06T11:11:41.317Z",
  "coverageGoal": 60,
  "attempts": [
    {
      "attempt": 1,
      "coverage": 0,
      "passed": false,
      "error": "Command failed: npm test -- --coverage --json --outputFile=coverage-report.json\nFAIL tests/controllers/simpleControllers.test.js\n  Simple Controller Tests\n    StrategyController\n      ✕ should filter strategies by tier (1 ms)\n      ✕ should handle database errors in getStrategies\n      ✕ should check tier access for getStrategy (1 ms)\n    RecommendationController\n      ✕ should return recommendations based on tier\n      ✕ should handle limit parameter (2 ms)\n      ✕ should handle getRecommendationById not found\n\n  ● Simple Controller Tests › StrategyController › should filter strategies by tier\n\n    TypeError: mockDb.from(...).select(...).mockResolvedValue is not a function\n\n      50 |       ];\n      51 |\n    > 52 |       mockDb.from().select().mockResolvedValue({ \n         |                              ^\n      53 |         data: mockStrategies, \n      54 |         error: null \n      55 |       });\n\n      at Object.mockResolvedValue (tests/controllers/simpleControllers.test.js:52:30)\n\n  ● Simple Controller Tests › StrategyController › should handle database errors in getStrategies\n\n    TypeError: Cannot read properties of undefined (reading 'select')\n\n      66 |     it('should handle database errors in getStrategies', async () => {\n      67 |       const mockDb = require('../../src/config/database').db;\n    > 68 |       mockDb.from().select().mockResolvedValue({ \n         |                    ^\n      69 |         data: null, \n      70 |         error: { message: 'Database error' } \n      71 |       });\n\n      at Object.<anonymous> (tests/controllers/simpleControllers.test.js:68:20)\n\n  ● Simple Controller Tests › StrategyController › should check tier access for getStrategy\n\n    TypeError: Cannot read properties of undefined (reading 'select')\n\n      81 |\n      82 |       const mockDb = require('../../src/config/database').db;\n    > 83 |       mockDb.from().select().eq().single().mockResolvedValue({ \n         |                    ^\n      84 |         data: { id: '123', name: 'Premium Strategy', min_tier: 'premium' }, \n      85 |         error: null \n      86 |       });\n\n      at Object.<anonymous> (tests/controllers/simpleControllers.test.js:83:20)\n\n  ● Simple Controller Tests › RecommendationController › should return recommendations based on tier\n\n    TypeError: Cannot read properties of undefined (reading 'select')\n\n       99 |       \n      100 |       const mockDb = require('../../src/config/database').db;\n    > 101 |       mockDb.from().select().order().limit().range().mockResolvedValue({ \n          |                    ^\n      102 |         data: [\n      103 |           { id: 1, symbol: 'AAPL', action: 'buy' },\n      104 |           { id: 2, symbol: 'GOOGL', action: 'buy' }\n\n      at Object.<anonymous> (tests/controllers/simpleControllers.test.js:101:20)\n\n  ● Simple Controller Tests › RecommendationController › should handle limit parameter\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 5\n\n    Number of calls: 0\n\n      129 |       await recommendationController.getRecommendations(req, res, next);\n      130 |\n    > 131 |       expect(mockChain.limit).toHaveBeenCalledWith(5);\n          |                               ^\n      132 |     });\n      133 |\n      134 |     it('should handle getRecommendationById not found', async () => {\n\n      at Object.toHaveBeenCalledWith (tests/controllers/simpleControllers.test.js:131:31)\n\n  ● Simple Controller Tests › RecommendationController › should handle getRecommendationById not found\n\n    TypeError: Cannot read properties of undefined (reading 'select')\n\n      136 |       \n      137 |       const mockDb = require('../../src/config/database').db;\n    > 138 |       mockDb.from().select().eq().single().mockResolvedValue({ \n          |                    ^\n      139 |         data: null, \n      140 |         error: null \n      141 |       });\n\n      at Object.<anonymous> (tests/controllers/simpleControllers.test.js:138:20)\n\nFAIL tests/middleware/auth.test.js\n  Auth Middleware\n    authenticate\n      ✕ should authenticate valid token (1 ms)\n      ✕ should reject missing token\n      ✕ should reject invalid token format (1 ms)\n      ✕ should handle JWT verification errors\n      ✕ should handle user not found\n      ✕ should handle database errors (1 ms)\n    authorize\n      ✓ should allow access for matching tier\n      ✕ should deny access for non-matching tier\n      ✕ should handle missing user\n    validateApiKey\n      ✕ should validate correct API key (1 ms)\n      ✕ should reject missing API key\n      ✕ should reject invalid API key\n      ✕ should reject inactive API key\n    tierRateLimit\n      ✕ should create tier-specific rate limiters\n\n  ● Auth Middleware › authenticate › should authenticate valid token\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: ObjectContaining {\"email\": \"test@example.com\", \"id\": \"user-123\", \"tier\": \"basic\"}\n    Received: undefined\n\n      54 |       await authenticate(req, res, next);\n      55 |\n    > 56 |       expect(req.user).toEqual(expect.objectContaining({\n         |                        ^\n      57 |         id: 'user-123',\n      58 |         email: 'test@example.com',\n      59 |         tier: 'basic'\n\n      at Object.toEqual (tests/middleware/auth.test.js:56:24)\n\n  ● Auth Middleware › authenticate › should reject missing token\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Authentication required\", \"status\": 401}\n\n    Number of calls: 0\n\n      65 |       await authenticate(req, res, next);\n      66 |\n    > 67 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n         |                    ^\n      68 |         status: 401,\n      69 |         message: 'Authentication required'\n      70 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:67:20)\n\n  ● Auth Middleware › authenticate › should reject invalid token format\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Invalid token format\", \"status\": 401}\n\n    Number of calls: 0\n\n      76 |       await authenticate(req, res, next);\n      77 |\n    > 78 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n         |                    ^\n      79 |         status: 401,\n      80 |         message: 'Invalid token format'\n      81 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:78:20)\n\n  ● Auth Middleware › authenticate › should handle JWT verification errors\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Invalid token\", \"status\": 401}\n\n    Number of calls: 0\n\n      90 |       await authenticate(req, res, next);\n      91 |\n    > 92 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n         |                    ^\n      93 |         status: 401,\n      94 |         message: 'Invalid token'\n      95 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:92:20)\n\n  ● Auth Middleware › authenticate › should handle user not found\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"User not found\", \"status\": 401}\n\n    Number of calls: 0\n\n      106 |       await authenticate(req, res, next);\n      107 |\n    > 108 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      109 |         status: 401,\n      110 |         message: 'User not found'\n      111 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:108:20)\n\n  ● Auth Middleware › authenticate › should handle database errors\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Database error\", \"status\": 401}\n\n    Number of calls: 0\n\n      122 |       await authenticate(req, res, next);\n      123 |\n    > 124 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      125 |         status: 401,\n      126 |         message: 'Database error'\n      127 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:124:20)\n\n  ● Auth Middleware › authorize › should deny access for non-matching tier\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Insufficient subscription tier\", \"status\": 403}\n    Received: called with 0 arguments\n\n    Number of calls: 1\n\n      146 |       middleware(req, res, next);\n      147 |\n    > 148 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      149 |         status: 403,\n      150 |         message: 'Insufficient subscription tier'\n      151 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:148:20)\n\n  ● Auth Middleware › authorize › should handle missing user\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Insufficient subscription tier\", \"status\": 403}\n\n    Number of calls: 0\n\n      157 |       middleware(req, res, next);\n      158 |\n    > 159 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      160 |         status: 403,\n      161 |         message: 'Insufficient subscription tier'\n      162 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:159:20)\n\n  ● Auth Middleware › validateApiKey › should validate correct API key\n\n    TypeError: validateApiKey is not a function\n\n      183 |       require('../../src/config/database').db.from.mockReturnValue(mockApiKey);\n      184 |\n    > 185 |       await validateApiKey(req, res, next);\n          |             ^\n      186 |\n      187 |       expect(req.apiKey).toEqual(expect.objectContaining({\n      188 |         id: 'key-123'\n\n      at Object.validateApiKey (tests/middleware/auth.test.js:185:13)\n\n  ● Auth Middleware › validateApiKey › should reject missing API key\n\n    TypeError: validateApiKey is not a function\n\n      192 |\n      193 |     it('should reject missing API key', async () => {\n    > 194 |       await validateApiKey(req, res, next);\n          |             ^\n      195 |\n      196 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n      197 |         status: 401,\n\n      at Object.validateApiKey (tests/middleware/auth.test.js:194:13)\n\n  ● Auth Middleware › validateApiKey › should reject invalid API key\n\n    TypeError: validateApiKey is not a function\n\n      214 |       require('../../src/config/database').db.from.mockReturnValue(mockApiKey);\n      215 |\n    > 216 |       await validateApiKey(req, res, next);\n          |             ^\n      217 |\n      218 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n      219 |         status: 401,\n\n      at Object.validateApiKey (tests/middleware/auth.test.js:216:13)\n\n  ● Auth Middleware › validateApiKey › should reject inactive API key\n\n    TypeError: validateApiKey is not a function\n\n      239 |       require('../../src/config/database').db.from.mockReturnValue(mockApiKey);\n      240 |\n    > 241 |       await validateApiKey(req, res, next);\n          |             ^\n      242 |\n      243 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n      244 |         status: 401,\n\n      at Object.validateApiKey (tests/middleware/auth.test.js:241:13)\n\n  ● Auth Middleware › tierRateLimit › should create tier-specific rate limiters\n\n    expect(received).toBeDefined()\n\n    Received: undefined\n\n      254 |       const professionalLimiter = tierRateLimit.professional;\n      255 |\n    > 256 |       expect(basicLimiter).toBeDefined();\n          |                            ^\n      257 |       expect(premiumLimiter).toBeDefined();\n      258 |       expect(professionalLimiter).toBeDefined();\n      259 |       expect(typeof basicLimiter).toBe('function');\n\n      at Object.toBeDefined (tests/middleware/auth.test.js:256:28)\n\nFAIL tests/utils/logger.test.js\n  Logger Utility\n    ✕ should create logger instance\n    ✓ should have all log methods (1 ms)\n    ✕ should have correct log level in test environment\n    ✓ should log without errors\n    ✓ should handle log with metadata\n    ✓ should handle various log formats\n\n  ● Logger Utility › should create logger instance\n\n    expect(received).toBeDefined()\n\n    Received: undefined\n\n       5 |   it('should create logger instance', () => {\n       6 |     expect(logger).toBeDefined();\n    >  7 |     expect(logger.transports).toBeDefined();\n         |                               ^\n       8 |   });\n       9 |\n      10 |   it('should have all log methods', () => {\n\n      at Object.toBeDefined (tests/utils/logger.test.js:7:31)\n\n  ● Logger Utility › should have correct log level in test environment\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: \"silent\"\n    Received: undefined\n\n      17 |   it('should have correct log level in test environment', () => {\n      18 |     // 테스트 환경에서는 silent 레벨이어야 함\n    > 19 |     expect(logger.level).toBe('silent');\n         |                          ^\n      20 |   });\n      21 |\n      22 |   it('should log without errors', () => {\n\n      at Object.toBe (tests/utils/logger.test.js:19:26)\n\nFAIL tests/controllers/authController.test.js\n  AuthController - Simple Tests\n    register\n      ✕ should handle registration errors gracefully (1 ms)\n      ✓ should handle unexpected errors\n    login\n      ✕ should handle invalid credentials (1 ms)\n    logout\n      ✕ should handle logout without token (1 ms)\n      ✕ should handle logout with token (1 ms)\n    changePassword\n      ✕ should handle password update errors\n    deleteAccount\n      ✓ should handle account deletion errors (1 ms)\n    refreshToken\n      ✕ should handle missing refresh token\n\n  ● AuthController - Simple Tests › register › should handle registration errors gracefully\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"User already exists\", \"status\": 400}\n    Received: [TypeError: Cannot read properties of undefined (reading 'isEmpty')]\n\n    Number of calls: 1\n\n      54 |       await authController.register(req, res, next);\n      55 |\n    > 56 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n         |                    ^\n      57 |         status: 400,\n      58 |         message: 'User already exists'\n      59 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:56:20)\n\n  ● AuthController - Simple Tests › login › should handle invalid credentials\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Invalid credentials\", \"status\": 401}\n    Received: [TypeError: Cannot read properties of undefined (reading 'isEmpty')]\n\n    Number of calls: 1\n\n      88 |       await authController.login(req, res, next);\n      89 |\n    > 90 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n         |                    ^\n      91 |         status: 401,\n      92 |         message: 'Invalid credentials'\n      93 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:90:20)\n\n  ● AuthController - Simple Tests › logout › should handle logout without token\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    - Expected\n    + Received\n\n      Object {\n    -   \"message\": \"Logged out successfully\",\n    +   \"message\": \"Logout successful\",\n      },\n\n    Number of calls: 1\n\n      101 |       await authController.logout(req, res, next);\n      102 |\n    > 103 |       expect(res.json).toHaveBeenCalledWith({\n          |                        ^\n      104 |         message: 'Logged out successfully'\n      105 |       });\n      106 |     });\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:103:24)\n\n  ● AuthController - Simple Tests › logout › should handle logout with token\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    - Expected\n    + Received\n\n      Object {\n    -   \"message\": \"Logged out successfully\",\n    +   \"message\": \"Logout successful\",\n      },\n\n    Number of calls: 1\n\n      112 |       await authController.logout(req, res, next);\n      113 |\n    > 114 |       expect(res.json).toHaveBeenCalledWith({\n          |                        ^\n      115 |         message: 'Logged out successfully'\n      116 |       });\n      117 |     });\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:114:24)\n\n  ● AuthController - Simple Tests › changePassword › should handle password update errors\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"status\": 400}\n    Received: [TypeError: Cannot read properties of undefined (reading 'isEmpty')]\n\n    Number of calls: 1\n\n      131 |       await authController.changePassword(req, res, next);\n      132 |\n    > 133 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      134 |         status: 400\n      135 |       }));\n      136 |     });\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:133:20)\n\n  ● AuthController - Simple Tests › refreshToken › should handle missing refresh token\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Refresh token required\", \"status\": 400}\n\n    Number of calls: 0\n\n      159 |       await authController.refreshToken(req, res, next);\n      160 |\n    > 161 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      162 |         status: 400,\n      163 |         message: 'Refresh token required'\n      164 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:161:20)\n\nFAIL tests/middleware/rateLimiter.test.js\n  Rate Limiter Middleware\n    ✕ should export rate limiter functions (1 ms)\n    ✕ should create rate limiter with custom options\n    ✕ should create rate limiter with message function (1 ms)\n    ✕ should have different limits for different limiters\n    ✕ should handle skip function\n    ✕ should handle standardHeaders option\n\n  ● Rate Limiter Middleware › should export rate limiter functions\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: \"function\"\n    Received: \"undefined\"\n\n      4 |   it('should export rate limiter functions', () => {\n      5 |     expect(rateLimiter).toBeDefined();\n    > 6 |     expect(typeof rateLimiter.createRateLimiter).toBe('function');\n        |                                                  ^\n      7 |     expect(typeof rateLimiter.apiLimiter).toBe('function');\n      8 |     expect(typeof rateLimiter.authLimiter).toBe('function');\n      9 |   });\n\n      at Object.toBe (tests/middleware/rateLimiter.test.js:6:50)\n\n  ● Rate Limiter Middleware › should create rate limiter with custom options\n\n    TypeError: rateLimiter.createRateLimiter is not a function\n\n      10 |\n      11 |   it('should create rate limiter with custom options', () => {\n    > 12 |     const customLimiter = rateLimiter.createRateLimiter({\n         |                                       ^\n      13 |       windowMs: 5 * 60 * 1000,\n      14 |       max: 10\n      15 |     });\n\n      at Object.createRateLimiter (tests/middleware/rateLimiter.test.js:12:39)\n\n  ● Rate Limiter Middleware › should create rate limiter with message function\n\n    TypeError: rateLimiter.createRateLimiter is not a function\n\n      20 |\n      21 |   it('should create rate limiter with message function', () => {\n    > 22 |     const customLimiter = rateLimiter.createRateLimiter({\n         |                                       ^\n      23 |       windowMs: 1 * 60 * 1000,\n      24 |       max: 5,\n      25 |       message: (req, res) => {\n\n      at Object.createRateLimiter (tests/middleware/rateLimiter.test.js:22:39)\n\n  ● Rate Limiter Middleware › should have different limits for different limiters\n\n    expect(received).toBeDefined()\n\n    Received: undefined\n\n      33 |   it('should have different limits for different limiters', () => {\n      34 |     // API limiter와 Auth limiter는 다른 설정을 가져야 함\n    > 35 |     expect(rateLimiter.apiLimiter).toBeDefined();\n         |                                    ^\n      36 |     expect(rateLimiter.authLimiter).toBeDefined();\n      37 |     expect(rateLimiter.apiLimiter).not.toBe(rateLimiter.authLimiter);\n      38 |   });\n\n      at Object.toBeDefined (tests/middleware/rateLimiter.test.js:35:36)\n\n  ● Rate Limiter Middleware › should handle skip function\n\n    TypeError: rateLimiter.createRateLimiter is not a function\n\n      39 |\n      40 |   it('should handle skip function', () => {\n    > 41 |     const skipLimiter = rateLimiter.createRateLimiter({\n         |                                     ^\n      42 |       windowMs: 1 * 60 * 1000,\n      43 |       max: 5,\n      44 |       skip: (req) => req.ip === '127.0.0.1'\n\n      at Object.createRateLimiter (tests/middleware/rateLimiter.test.js:41:37)\n\n  ● Rate Limiter Middleware › should handle standardHeaders option\n\n    TypeError: rateLimiter.createRateLimiter is not a function\n\n      49 |\n      50 |   it('should handle standardHeaders option', () => {\n    > 51 |     const limiter = rateLimiter.createRateLimiter({\n         |                                 ^\n      52 |       windowMs: 1 * 60 * 1000,\n      53 |       max: 100,\n      54 |       standardHeaders: true,\n\n      at Object.createRateLimiter (tests/middleware/rateLimiter.test.js:51:33)\n\nFAIL tests/services/finnhubService.test.js\n  FinnhubService\n    constructor\n      ✕ should initialize with API key and cache\n    static methods\n      ✕ should format candles data correctly (1 ms)\n      ✕ should handle empty candles data\n      ✕ should handle missing candles data\n      ✕ should calculate period from date correctly\n      ✕ should handle invalid date for period calculation\n    cache operations\n      ✕ should check cache before making API call (1 ms)\n      ✕ should set cache with TTL\n    error handling\n      ✕ should handle missing API key\n    helper methods\n      ✕ should build correct URL with parameters\n\n  ● FinnhubService › constructor › should initialize with API key and cache\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › static methods › should format candles data correctly\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › static methods › should handle empty candles data\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › static methods › should handle missing candles data\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › static methods › should calculate period from date correctly\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › static methods › should handle invalid date for period calculation\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › cache operations › should check cache before making API call\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › cache operations › should set cache with TTL\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › error handling › should handle missing API key\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › helper methods › should build correct URL with parameters\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\nFAIL tests/middleware/errorHandler.test.js\n  Error Handler Middleware\n    ✕ should handle 400 validation error\n    ✕ should handle 401 unauthorized error\n    ✕ should handle 404 not found error\n    ✕ should handle 500 server error (1 ms)\n    ✕ should include details if provided\n    ✕ should include stack trace in development\n    ✕ should handle error without message\n    ✕ should handle non-Error objects\n\n  ● Error Handler Middleware › should handle 400 validation error\n\n    TypeError: errorHandler is not a function\n\n      17 |     error.status = 400;\n      18 |\n    > 19 |     errorHandler(error, req, res, next);\n         |     ^\n      20 |\n      21 |     expect(res.status).toHaveBeenCalledWith(400);\n      22 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:19:5)\n\n  ● Error Handler Middleware › should handle 401 unauthorized error\n\n    TypeError: errorHandler is not a function\n\n      30 |     error.status = 401;\n      31 |\n    > 32 |     errorHandler(error, req, res, next);\n         |     ^\n      33 |\n      34 |     expect(res.status).toHaveBeenCalledWith(401);\n      35 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:32:5)\n\n  ● Error Handler Middleware › should handle 404 not found error\n\n    TypeError: errorHandler is not a function\n\n      43 |     error.status = 404;\n      44 |\n    > 45 |     errorHandler(error, req, res, next);\n         |     ^\n      46 |\n      47 |     expect(res.status).toHaveBeenCalledWith(404);\n      48 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:45:5)\n\n  ● Error Handler Middleware › should handle 500 server error\n\n    TypeError: errorHandler is not a function\n\n      56 |     // No status means 500\n      57 |\n    > 58 |     errorHandler(error, req, res, next);\n         |     ^\n      59 |\n      60 |     expect(res.status).toHaveBeenCalledWith(500);\n      61 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:58:5)\n\n  ● Error Handler Middleware › should include details if provided\n\n    TypeError: errorHandler is not a function\n\n      70 |     error.details = { field: 'email', message: 'Invalid format' };\n      71 |\n    > 72 |     errorHandler(error, req, res, next);\n         |     ^\n      73 |\n      74 |     expect(res.json).toHaveBeenCalledWith({\n      75 |       error: 'Bad Request',\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:72:5)\n\n  ● Error Handler Middleware › should include stack trace in development\n\n    TypeError: errorHandler is not a function\n\n      85 |     error.stack = 'Error: Dev Error\\n    at test.js:10:5';\n      86 |\n    > 87 |     errorHandler(error, req, res, next);\n         |     ^\n      88 |\n      89 |     expect(res.json).toHaveBeenCalledWith({\n      90 |       error: 'Internal server error',\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:87:5)\n\n  ● Error Handler Middleware › should handle error without message\n\n    TypeError: errorHandler is not a function\n\n      100 |     error.status = 403;\n      101 |\n    > 102 |     errorHandler(error, req, res, next);\n          |     ^\n      103 |\n      104 |     expect(res.status).toHaveBeenCalledWith(403);\n      105 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:102:5)\n\n  ● Error Handler Middleware › should handle non-Error objects\n\n    TypeError: errorHandler is not a function\n\n      112 |     const error = { message: 'Custom error', code: 'CUSTOM_ERROR' };\n      113 |\n    > 114 |     errorHandler(error, req, res, next);\n          |     ^\n      115 |\n      116 |     expect(res.status).toHaveBeenCalledWith(500);\n      117 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:114:5)\n\nFAIL tests/validators/validators.test.js\n  ● Test suite failed to run\n\n    TypeError: body is not a function\n\n      2 |\n      3 | const validateRegister = [\n    > 4 |   body('email')\n        |   ^\n      5 |     .isEmail()\n      6 |     .normalizeEmail()\n      7 |     .withMessage('Please provide a valid email'),\n\n      at Object.body (src/validators/auth.js:4:3)\n      at Object.<anonymous> (tests/validators/validators.test.js:1:60)\n\nJest: \"global\" coverage threshold for statements (60%) not met: 15.94%\nJest: \"global\" coverage threshold for branches (50%) not met: 6.66%\nJest: \"global\" coverage threshold for lines (60%) not met: 16.97%\nJest: \"global\" coverage threshold for functions (50%) not met: 13.18%\nTest Suites: 8 failed, 8 total\nTests:       51 failed, 7 passed, 58 total\nSnapshots:   0 total\nTime:        0.689 s, estimated 1 s\nRan all test suites.\nTest results written to: coverage-report.json\n"
    },
    {
      "attempt": 2,
      "coverage": 0,
      "passed": false,
      "error": "Command failed: npm test -- --coverage --json --outputFile=coverage-report.json\nFAIL tests/controllers/simpleControllers.test.js\n  Simple Controller Tests\n    StrategyController\n      ✕ should filter strategies by tier (1 ms)\n      ✕ should handle database errors in getStrategies\n      ✕ should check tier access for getStrategy (1 ms)\n    RecommendationController\n      ✕ should return recommendations based on tier\n      ✕ should handle limit parameter (2 ms)\n      ✕ should handle getRecommendationById not found (1 ms)\n\n  ● Simple Controller Tests › StrategyController › should filter strategies by tier\n\n    TypeError: mockDb.from(...).select(...).mockResolvedValue is not a function\n\n      50 |       ];\n      51 |\n    > 52 |       mockDb.from().select().mockResolvedValue({ \n         |                              ^\n      53 |         data: mockStrategies, \n      54 |         error: null \n      55 |       });\n\n      at Object.mockResolvedValue (tests/controllers/simpleControllers.test.js:52:30)\n\n  ● Simple Controller Tests › StrategyController › should handle database errors in getStrategies\n\n    TypeError: Cannot read properties of undefined (reading 'select')\n\n      66 |     it('should handle database errors in getStrategies', async () => {\n      67 |       const mockDb = require('../../src/config/database').db;\n    > 68 |       mockDb.from().select().mockResolvedValue({ \n         |                    ^\n      69 |         data: null, \n      70 |         error: { message: 'Database error' } \n      71 |       });\n\n      at Object.<anonymous> (tests/controllers/simpleControllers.test.js:68:20)\n\n  ● Simple Controller Tests › StrategyController › should check tier access for getStrategy\n\n    TypeError: Cannot read properties of undefined (reading 'select')\n\n      81 |\n      82 |       const mockDb = require('../../src/config/database').db;\n    > 83 |       mockDb.from().select().eq().single().mockResolvedValue({ \n         |                    ^\n      84 |         data: { id: '123', name: 'Premium Strategy', min_tier: 'premium' }, \n      85 |         error: null \n      86 |       });\n\n      at Object.<anonymous> (tests/controllers/simpleControllers.test.js:83:20)\n\n  ● Simple Controller Tests › RecommendationController › should return recommendations based on tier\n\n    TypeError: Cannot read properties of undefined (reading 'select')\n\n       99 |       \n      100 |       const mockDb = require('../../src/config/database').db;\n    > 101 |       mockDb.from().select().order().limit().range().mockResolvedValue({ \n          |                    ^\n      102 |         data: [\n      103 |           { id: 1, symbol: 'AAPL', action: 'buy' },\n      104 |           { id: 2, symbol: 'GOOGL', action: 'buy' }\n\n      at Object.<anonymous> (tests/controllers/simpleControllers.test.js:101:20)\n\n  ● Simple Controller Tests › RecommendationController › should handle limit parameter\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 5\n\n    Number of calls: 0\n\n      129 |       await recommendationController.getRecommendations(req, res, next);\n      130 |\n    > 131 |       expect(mockChain.limit).toHaveBeenCalledWith(5);\n          |                               ^\n      132 |     });\n      133 |\n      134 |     it('should handle getRecommendationById not found', async () => {\n\n      at Object.toHaveBeenCalledWith (tests/controllers/simpleControllers.test.js:131:31)\n\n  ● Simple Controller Tests › RecommendationController › should handle getRecommendationById not found\n\n    TypeError: Cannot read properties of undefined (reading 'select')\n\n      136 |       \n      137 |       const mockDb = require('../../src/config/database').db;\n    > 138 |       mockDb.from().select().eq().single().mockResolvedValue({ \n          |                    ^\n      139 |         data: null, \n      140 |         error: null \n      141 |       });\n\n      at Object.<anonymous> (tests/controllers/simpleControllers.test.js:138:20)\n\nFAIL tests/middleware/auth.test.js\n  Auth Middleware\n    authenticate\n      ✕ should authenticate valid token (1 ms)\n      ✕ should reject missing token\n      ✕ should reject invalid token format\n      ✕ should handle JWT verification errors (1 ms)\n      ✕ should handle user not found\n      ✕ should handle database errors\n    authorize\n      ✓ should allow access for matching tier (1 ms)\n      ✕ should deny access for non-matching tier\n      ✕ should handle missing user (1 ms)\n    validateApiKey\n      ✕ should validate correct API key\n      ✕ should reject missing API key\n      ✕ should reject invalid API key\n      ✕ should reject inactive API key\n    tierRateLimit\n      ✕ should create tier-specific rate limiters\n\n  ● Auth Middleware › authenticate › should authenticate valid token\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: ObjectContaining {\"email\": \"test@example.com\", \"id\": \"user-123\", \"tier\": \"basic\"}\n    Received: undefined\n\n      54 |       await authenticate(req, res, next);\n      55 |\n    > 56 |       expect(req.user).toEqual(expect.objectContaining({\n         |                        ^\n      57 |         id: 'user-123',\n      58 |         email: 'test@example.com',\n      59 |         tier: 'basic'\n\n      at Object.toEqual (tests/middleware/auth.test.js:56:24)\n\n  ● Auth Middleware › authenticate › should reject missing token\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Authentication required\", \"status\": 401}\n\n    Number of calls: 0\n\n      65 |       await authenticate(req, res, next);\n      66 |\n    > 67 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n         |                    ^\n      68 |         status: 401,\n      69 |         message: 'Authentication required'\n      70 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:67:20)\n\n  ● Auth Middleware › authenticate › should reject invalid token format\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Invalid token format\", \"status\": 401}\n\n    Number of calls: 0\n\n      76 |       await authenticate(req, res, next);\n      77 |\n    > 78 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n         |                    ^\n      79 |         status: 401,\n      80 |         message: 'Invalid token format'\n      81 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:78:20)\n\n  ● Auth Middleware › authenticate › should handle JWT verification errors\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Invalid token\", \"status\": 401}\n\n    Number of calls: 0\n\n      90 |       await authenticate(req, res, next);\n      91 |\n    > 92 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n         |                    ^\n      93 |         status: 401,\n      94 |         message: 'Invalid token'\n      95 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:92:20)\n\n  ● Auth Middleware › authenticate › should handle user not found\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"User not found\", \"status\": 401}\n\n    Number of calls: 0\n\n      106 |       await authenticate(req, res, next);\n      107 |\n    > 108 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      109 |         status: 401,\n      110 |         message: 'User not found'\n      111 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:108:20)\n\n  ● Auth Middleware › authenticate › should handle database errors\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Database error\", \"status\": 401}\n\n    Number of calls: 0\n\n      122 |       await authenticate(req, res, next);\n      123 |\n    > 124 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      125 |         status: 401,\n      126 |         message: 'Database error'\n      127 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:124:20)\n\n  ● Auth Middleware › authorize › should deny access for non-matching tier\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Insufficient subscription tier\", \"status\": 403}\n    Received: called with 0 arguments\n\n    Number of calls: 1\n\n      146 |       middleware(req, res, next);\n      147 |\n    > 148 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      149 |         status: 403,\n      150 |         message: 'Insufficient subscription tier'\n      151 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:148:20)\n\n  ● Auth Middleware › authorize › should handle missing user\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Insufficient subscription tier\", \"status\": 403}\n\n    Number of calls: 0\n\n      157 |       middleware(req, res, next);\n      158 |\n    > 159 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      160 |         status: 403,\n      161 |         message: 'Insufficient subscription tier'\n      162 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:159:20)\n\n  ● Auth Middleware › validateApiKey › should validate correct API key\n\n    TypeError: validateApiKey is not a function\n\n      183 |       require('../../src/config/database').db.from.mockReturnValue(mockApiKey);\n      184 |\n    > 185 |       await validateApiKey(req, res, next);\n          |             ^\n      186 |\n      187 |       expect(req.apiKey).toEqual(expect.objectContaining({\n      188 |         id: 'key-123'\n\n      at Object.validateApiKey (tests/middleware/auth.test.js:185:13)\n\n  ● Auth Middleware › validateApiKey › should reject missing API key\n\n    TypeError: validateApiKey is not a function\n\n      192 |\n      193 |     it('should reject missing API key', async () => {\n    > 194 |       await validateApiKey(req, res, next);\n          |             ^\n      195 |\n      196 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n      197 |         status: 401,\n\n      at Object.validateApiKey (tests/middleware/auth.test.js:194:13)\n\n  ● Auth Middleware › validateApiKey › should reject invalid API key\n\n    TypeError: validateApiKey is not a function\n\n      214 |       require('../../src/config/database').db.from.mockReturnValue(mockApiKey);\n      215 |\n    > 216 |       await validateApiKey(req, res, next);\n          |             ^\n      217 |\n      218 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n      219 |         status: 401,\n\n      at Object.validateApiKey (tests/middleware/auth.test.js:216:13)\n\n  ● Auth Middleware › validateApiKey › should reject inactive API key\n\n    TypeError: validateApiKey is not a function\n\n      239 |       require('../../src/config/database').db.from.mockReturnValue(mockApiKey);\n      240 |\n    > 241 |       await validateApiKey(req, res, next);\n          |             ^\n      242 |\n      243 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n      244 |         status: 401,\n\n      at Object.validateApiKey (tests/middleware/auth.test.js:241:13)\n\n  ● Auth Middleware › tierRateLimit › should create tier-specific rate limiters\n\n    expect(received).toBeDefined()\n\n    Received: undefined\n\n      254 |       const professionalLimiter = tierRateLimit.professional;\n      255 |\n    > 256 |       expect(basicLimiter).toBeDefined();\n          |                            ^\n      257 |       expect(premiumLimiter).toBeDefined();\n      258 |       expect(professionalLimiter).toBeDefined();\n      259 |       expect(typeof basicLimiter).toBe('function');\n\n      at Object.toBeDefined (tests/middleware/auth.test.js:256:28)\n\nFAIL tests/controllers/authController.test.js\n  AuthController - Simple Tests\n    register\n      ✕ should handle registration errors gracefully\n      ✓ should handle unexpected errors\n    login\n      ✕ should handle invalid credentials\n    logout\n      ✕ should handle logout without token (2 ms)\n      ✕ should handle logout with token\n    changePassword\n      ✕ should handle password update errors\n    deleteAccount\n      ✓ should handle account deletion errors (1 ms)\n    refreshToken\n      ✕ should handle missing refresh token\n\n  ● AuthController - Simple Tests › register › should handle registration errors gracefully\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"User already exists\", \"status\": 400}\n    Received: [TypeError: Cannot read properties of undefined (reading 'isEmpty')]\n\n    Number of calls: 1\n\n      54 |       await authController.register(req, res, next);\n      55 |\n    > 56 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n         |                    ^\n      57 |         status: 400,\n      58 |         message: 'User already exists'\n      59 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:56:20)\n\n  ● AuthController - Simple Tests › login › should handle invalid credentials\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Invalid credentials\", \"status\": 401}\n    Received: [TypeError: Cannot read properties of undefined (reading 'isEmpty')]\n\n    Number of calls: 1\n\n      88 |       await authController.login(req, res, next);\n      89 |\n    > 90 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n         |                    ^\n      91 |         status: 401,\n      92 |         message: 'Invalid credentials'\n      93 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:90:20)\n\n  ● AuthController - Simple Tests › logout › should handle logout without token\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    - Expected\n    + Received\n\n      Object {\n    -   \"message\": \"Logged out successfully\",\n    +   \"message\": \"Logout successful\",\n      },\n\n    Number of calls: 1\n\n      101 |       await authController.logout(req, res, next);\n      102 |\n    > 103 |       expect(res.json).toHaveBeenCalledWith({\n          |                        ^\n      104 |         message: 'Logged out successfully'\n      105 |       });\n      106 |     });\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:103:24)\n\n  ● AuthController - Simple Tests › logout › should handle logout with token\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    - Expected\n    + Received\n\n      Object {\n    -   \"message\": \"Logged out successfully\",\n    +   \"message\": \"Logout successful\",\n      },\n\n    Number of calls: 1\n\n      112 |       await authController.logout(req, res, next);\n      113 |\n    > 114 |       expect(res.json).toHaveBeenCalledWith({\n          |                        ^\n      115 |         message: 'Logged out successfully'\n      116 |       });\n      117 |     });\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:114:24)\n\n  ● AuthController - Simple Tests › changePassword › should handle password update errors\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"status\": 400}\n    Received: [TypeError: Cannot read properties of undefined (reading 'isEmpty')]\n\n    Number of calls: 1\n\n      131 |       await authController.changePassword(req, res, next);\n      132 |\n    > 133 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      134 |         status: 400\n      135 |       }));\n      136 |     });\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:133:20)\n\n  ● AuthController - Simple Tests › refreshToken › should handle missing refresh token\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Refresh token required\", \"status\": 400}\n\n    Number of calls: 0\n\n      159 |       await authController.refreshToken(req, res, next);\n      160 |\n    > 161 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      162 |         status: 400,\n      163 |         message: 'Refresh token required'\n      164 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:161:20)\n\nFAIL tests/middleware/errorHandler.test.js\n  Error Handler Middleware\n    ✕ should handle 400 validation error\n    ✕ should handle 401 unauthorized error\n    ✕ should handle 404 not found error\n    ✕ should handle 500 server error\n    ✕ should include details if provided\n    ✕ should include stack trace in development\n    ✕ should handle error without message\n    ✕ should handle non-Error objects\n\n  ● Error Handler Middleware › should handle 400 validation error\n\n    TypeError: errorHandler is not a function\n\n      17 |     error.status = 400;\n      18 |\n    > 19 |     errorHandler(error, req, res, next);\n         |     ^\n      20 |\n      21 |     expect(res.status).toHaveBeenCalledWith(400);\n      22 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:19:5)\n\n  ● Error Handler Middleware › should handle 401 unauthorized error\n\n    TypeError: errorHandler is not a function\n\n      30 |     error.status = 401;\n      31 |\n    > 32 |     errorHandler(error, req, res, next);\n         |     ^\n      33 |\n      34 |     expect(res.status).toHaveBeenCalledWith(401);\n      35 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:32:5)\n\n  ● Error Handler Middleware › should handle 404 not found error\n\n    TypeError: errorHandler is not a function\n\n      43 |     error.status = 404;\n      44 |\n    > 45 |     errorHandler(error, req, res, next);\n         |     ^\n      46 |\n      47 |     expect(res.status).toHaveBeenCalledWith(404);\n      48 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:45:5)\n\n  ● Error Handler Middleware › should handle 500 server error\n\n    TypeError: errorHandler is not a function\n\n      56 |     // No status means 500\n      57 |\n    > 58 |     errorHandler(error, req, res, next);\n         |     ^\n      59 |\n      60 |     expect(res.status).toHaveBeenCalledWith(500);\n      61 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:58:5)\n\n  ● Error Handler Middleware › should include details if provided\n\n    TypeError: errorHandler is not a function\n\n      70 |     error.details = { field: 'email', message: 'Invalid format' };\n      71 |\n    > 72 |     errorHandler(error, req, res, next);\n         |     ^\n      73 |\n      74 |     expect(res.json).toHaveBeenCalledWith({\n      75 |       error: 'Bad Request',\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:72:5)\n\n  ● Error Handler Middleware › should include stack trace in development\n\n    TypeError: errorHandler is not a function\n\n      85 |     error.stack = 'Error: Dev Error\\n    at test.js:10:5';\n      86 |\n    > 87 |     errorHandler(error, req, res, next);\n         |     ^\n      88 |\n      89 |     expect(res.json).toHaveBeenCalledWith({\n      90 |       error: 'Internal server error',\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:87:5)\n\n  ● Error Handler Middleware › should handle error without message\n\n    TypeError: errorHandler is not a function\n\n      100 |     error.status = 403;\n      101 |\n    > 102 |     errorHandler(error, req, res, next);\n          |     ^\n      103 |\n      104 |     expect(res.status).toHaveBeenCalledWith(403);\n      105 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:102:5)\n\n  ● Error Handler Middleware › should handle non-Error objects\n\n    TypeError: errorHandler is not a function\n\n      112 |     const error = { message: 'Custom error', code: 'CUSTOM_ERROR' };\n      113 |\n    > 114 |     errorHandler(error, req, res, next);\n          |     ^\n      115 |\n      116 |     expect(res.status).toHaveBeenCalledWith(500);\n      117 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:114:5)\n\nFAIL tests/middleware/rateLimiter.test.js\n  Rate Limiter Middleware\n    ✕ should export rate limiter functions (1 ms)\n    ✕ should create rate limiter with custom options\n    ✕ should create rate limiter with message function\n    ✕ should have different limits for different limiters\n    ✕ should handle skip function\n    ✕ should handle standardHeaders option\n\n  ● Rate Limiter Middleware › should export rate limiter functions\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: \"function\"\n    Received: \"undefined\"\n\n      4 |   it('should export rate limiter functions', () => {\n      5 |     expect(rateLimiter).toBeDefined();\n    > 6 |     expect(typeof rateLimiter.createRateLimiter).toBe('function');\n        |                                                  ^\n      7 |     expect(typeof rateLimiter.apiLimiter).toBe('function');\n      8 |     expect(typeof rateLimiter.authLimiter).toBe('function');\n      9 |   });\n\n      at Object.toBe (tests/middleware/rateLimiter.test.js:6:50)\n\n  ● Rate Limiter Middleware › should create rate limiter with custom options\n\n    TypeError: rateLimiter.createRateLimiter is not a function\n\n      10 |\n      11 |   it('should create rate limiter with custom options', () => {\n    > 12 |     const customLimiter = rateLimiter.createRateLimiter({\n         |                                       ^\n      13 |       windowMs: 5 * 60 * 1000,\n      14 |       max: 10\n      15 |     });\n\n      at Object.createRateLimiter (tests/middleware/rateLimiter.test.js:12:39)\n\n  ● Rate Limiter Middleware › should create rate limiter with message function\n\n    TypeError: rateLimiter.createRateLimiter is not a function\n\n      20 |\n      21 |   it('should create rate limiter with message function', () => {\n    > 22 |     const customLimiter = rateLimiter.createRateLimiter({\n         |                                       ^\n      23 |       windowMs: 1 * 60 * 1000,\n      24 |       max: 5,\n      25 |       message: (req, res) => {\n\n      at Object.createRateLimiter (tests/middleware/rateLimiter.test.js:22:39)\n\n  ● Rate Limiter Middleware › should have different limits for different limiters\n\n    expect(received).toBeDefined()\n\n    Received: undefined\n\n      33 |   it('should have different limits for different limiters', () => {\n      34 |     // API limiter와 Auth limiter는 다른 설정을 가져야 함\n    > 35 |     expect(rateLimiter.apiLimiter).toBeDefined();\n         |                                    ^\n      36 |     expect(rateLimiter.authLimiter).toBeDefined();\n      37 |     expect(rateLimiter.apiLimiter).not.toBe(rateLimiter.authLimiter);\n      38 |   });\n\n      at Object.toBeDefined (tests/middleware/rateLimiter.test.js:35:36)\n\n  ● Rate Limiter Middleware › should handle skip function\n\n    TypeError: rateLimiter.createRateLimiter is not a function\n\n      39 |\n      40 |   it('should handle skip function', () => {\n    > 41 |     const skipLimiter = rateLimiter.createRateLimiter({\n         |                                     ^\n      42 |       windowMs: 1 * 60 * 1000,\n      43 |       max: 5,\n      44 |       skip: (req) => req.ip === '127.0.0.1'\n\n      at Object.createRateLimiter (tests/middleware/rateLimiter.test.js:41:37)\n\n  ● Rate Limiter Middleware › should handle standardHeaders option\n\n    TypeError: rateLimiter.createRateLimiter is not a function\n\n      49 |\n      50 |   it('should handle standardHeaders option', () => {\n    > 51 |     const limiter = rateLimiter.createRateLimiter({\n         |                                 ^\n      52 |       windowMs: 1 * 60 * 1000,\n      53 |       max: 100,\n      54 |       standardHeaders: true,\n\n      at Object.createRateLimiter (tests/middleware/rateLimiter.test.js:51:33)\n\nFAIL tests/services/finnhubService.test.js\n  FinnhubService\n    constructor\n      ✕ should initialize with API key and cache\n    static methods\n      ✕ should format candles data correctly\n      ✕ should handle empty candles data\n      ✕ should handle missing candles data\n      ✕ should calculate period from date correctly (1 ms)\n      ✕ should handle invalid date for period calculation\n    cache operations\n      ✕ should check cache before making API call\n      ✕ should set cache with TTL\n    error handling\n      ✕ should handle missing API key\n    helper methods\n      ✕ should build correct URL with parameters\n\n  ● FinnhubService › constructor › should initialize with API key and cache\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › static methods › should format candles data correctly\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › static methods › should handle empty candles data\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › static methods › should handle missing candles data\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › static methods › should calculate period from date correctly\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › static methods › should handle invalid date for period calculation\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › cache operations › should check cache before making API call\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › cache operations › should set cache with TTL\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › error handling › should handle missing API key\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › helper methods › should build correct URL with parameters\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\nFAIL tests/utils/logger.test.js\n  Logger Utility\n    ✕ should create logger instance (1 ms)\n    ✓ should have all log methods (1 ms)\n    ✕ should have correct log level in test environment\n    ✓ should log without errors (1 ms)\n    ✓ should handle log with metadata\n    ✓ should handle various log formats (1 ms)\n\n  ● Logger Utility › should create logger instance\n\n    expect(received).toBeDefined()\n\n    Received: undefined\n\n       5 |   it('should create logger instance', () => {\n       6 |     expect(logger).toBeDefined();\n    >  7 |     expect(logger.transports).toBeDefined();\n         |                               ^\n       8 |   });\n       9 |\n      10 |   it('should have all log methods', () => {\n\n      at Object.toBeDefined (tests/utils/logger.test.js:7:31)\n\n  ● Logger Utility › should have correct log level in test environment\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: \"silent\"\n    Received: undefined\n\n      17 |   it('should have correct log level in test environment', () => {\n      18 |     // 테스트 환경에서는 silent 레벨이어야 함\n    > 19 |     expect(logger.level).toBe('silent');\n         |                          ^\n      20 |   });\n      21 |\n      22 |   it('should log without errors', () => {\n\n      at Object.toBe (tests/utils/logger.test.js:19:26)\n\nFAIL tests/validators/validators.test.js\n  ● Test suite failed to run\n\n    TypeError: body is not a function\n\n      2 |\n      3 | const validateRegister = [\n    > 4 |   body('email')\n        |   ^\n      5 |     .isEmail()\n      6 |     .normalizeEmail()\n      7 |     .withMessage('Please provide a valid email'),\n\n      at Object.body (src/validators/auth.js:4:3)\n      at Object.<anonymous> (tests/validators/validators.test.js:1:60)\n\nJest: \"global\" coverage threshold for statements (60%) not met: 15.94%\nJest: \"global\" coverage threshold for branches (50%) not met: 6.66%\nJest: \"global\" coverage threshold for lines (60%) not met: 16.97%\nJest: \"global\" coverage threshold for functions (50%) not met: 13.18%\nTest Suites: 8 failed, 8 total\nTests:       51 failed, 7 passed, 58 total\nSnapshots:   0 total\nTime:        0.576 s, estimated 1 s\nRan all test suites.\nTest results written to: coverage-report.json\n"
    },
    {
      "attempt": 3,
      "coverage": 0,
      "passed": false,
      "error": "Command failed: npm test -- --coverage --json --outputFile=coverage-report.json\nFAIL tests/controllers/simpleControllers.test.js\n  Simple Controller Tests\n    StrategyController\n      ✕ should filter strategies by tier\n      ✕ should handle database errors in getStrategies\n      ✕ should check tier access for getStrategy\n    RecommendationController\n      ✕ should return recommendations based on tier\n      ✕ should handle limit parameter (3 ms)\n      ✕ should handle getRecommendationById not found\n\n  ● Simple Controller Tests › StrategyController › should filter strategies by tier\n\n    TypeError: mockDb.from(...).select(...).mockResolvedValue is not a function\n\n      50 |       ];\n      51 |\n    > 52 |       mockDb.from().select().mockResolvedValue({ \n         |                              ^\n      53 |         data: mockStrategies, \n      54 |         error: null \n      55 |       });\n\n      at Object.mockResolvedValue (tests/controllers/simpleControllers.test.js:52:30)\n\n  ● Simple Controller Tests › StrategyController › should handle database errors in getStrategies\n\n    TypeError: Cannot read properties of undefined (reading 'select')\n\n      66 |     it('should handle database errors in getStrategies', async () => {\n      67 |       const mockDb = require('../../src/config/database').db;\n    > 68 |       mockDb.from().select().mockResolvedValue({ \n         |                    ^\n      69 |         data: null, \n      70 |         error: { message: 'Database error' } \n      71 |       });\n\n      at Object.<anonymous> (tests/controllers/simpleControllers.test.js:68:20)\n\n  ● Simple Controller Tests › StrategyController › should check tier access for getStrategy\n\n    TypeError: Cannot read properties of undefined (reading 'select')\n\n      81 |\n      82 |       const mockDb = require('../../src/config/database').db;\n    > 83 |       mockDb.from().select().eq().single().mockResolvedValue({ \n         |                    ^\n      84 |         data: { id: '123', name: 'Premium Strategy', min_tier: 'premium' }, \n      85 |         error: null \n      86 |       });\n\n      at Object.<anonymous> (tests/controllers/simpleControllers.test.js:83:20)\n\n  ● Simple Controller Tests › RecommendationController › should return recommendations based on tier\n\n    TypeError: Cannot read properties of undefined (reading 'select')\n\n       99 |       \n      100 |       const mockDb = require('../../src/config/database').db;\n    > 101 |       mockDb.from().select().order().limit().range().mockResolvedValue({ \n          |                    ^\n      102 |         data: [\n      103 |           { id: 1, symbol: 'AAPL', action: 'buy' },\n      104 |           { id: 2, symbol: 'GOOGL', action: 'buy' }\n\n      at Object.<anonymous> (tests/controllers/simpleControllers.test.js:101:20)\n\n  ● Simple Controller Tests › RecommendationController › should handle limit parameter\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 5\n\n    Number of calls: 0\n\n      129 |       await recommendationController.getRecommendations(req, res, next);\n      130 |\n    > 131 |       expect(mockChain.limit).toHaveBeenCalledWith(5);\n          |                               ^\n      132 |     });\n      133 |\n      134 |     it('should handle getRecommendationById not found', async () => {\n\n      at Object.toHaveBeenCalledWith (tests/controllers/simpleControllers.test.js:131:31)\n\n  ● Simple Controller Tests › RecommendationController › should handle getRecommendationById not found\n\n    TypeError: Cannot read properties of undefined (reading 'select')\n\n      136 |       \n      137 |       const mockDb = require('../../src/config/database').db;\n    > 138 |       mockDb.from().select().eq().single().mockResolvedValue({ \n          |                    ^\n      139 |         data: null, \n      140 |         error: null \n      141 |       });\n\n      at Object.<anonymous> (tests/controllers/simpleControllers.test.js:138:20)\n\nFAIL tests/middleware/auth.test.js\n  Auth Middleware\n    authenticate\n      ✕ should authenticate valid token (1 ms)\n      ✕ should reject missing token\n      ✕ should reject invalid token format (1 ms)\n      ✕ should handle JWT verification errors\n      ✕ should handle user not found\n      ✕ should handle database errors\n    authorize\n      ✓ should allow access for matching tier\n      ✕ should deny access for non-matching tier\n      ✕ should handle missing user\n    validateApiKey\n      ✕ should validate correct API key\n      ✕ should reject missing API key\n      ✕ should reject invalid API key\n      ✕ should reject inactive API key\n    tierRateLimit\n      ✕ should create tier-specific rate limiters\n\n  ● Auth Middleware › authenticate › should authenticate valid token\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: ObjectContaining {\"email\": \"test@example.com\", \"id\": \"user-123\", \"tier\": \"basic\"}\n    Received: undefined\n\n      54 |       await authenticate(req, res, next);\n      55 |\n    > 56 |       expect(req.user).toEqual(expect.objectContaining({\n         |                        ^\n      57 |         id: 'user-123',\n      58 |         email: 'test@example.com',\n      59 |         tier: 'basic'\n\n      at Object.toEqual (tests/middleware/auth.test.js:56:24)\n\n  ● Auth Middleware › authenticate › should reject missing token\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Authentication required\", \"status\": 401}\n\n    Number of calls: 0\n\n      65 |       await authenticate(req, res, next);\n      66 |\n    > 67 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n         |                    ^\n      68 |         status: 401,\n      69 |         message: 'Authentication required'\n      70 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:67:20)\n\n  ● Auth Middleware › authenticate › should reject invalid token format\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Invalid token format\", \"status\": 401}\n\n    Number of calls: 0\n\n      76 |       await authenticate(req, res, next);\n      77 |\n    > 78 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n         |                    ^\n      79 |         status: 401,\n      80 |         message: 'Invalid token format'\n      81 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:78:20)\n\n  ● Auth Middleware › authenticate › should handle JWT verification errors\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Invalid token\", \"status\": 401}\n\n    Number of calls: 0\n\n      90 |       await authenticate(req, res, next);\n      91 |\n    > 92 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n         |                    ^\n      93 |         status: 401,\n      94 |         message: 'Invalid token'\n      95 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:92:20)\n\n  ● Auth Middleware › authenticate › should handle user not found\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"User not found\", \"status\": 401}\n\n    Number of calls: 0\n\n      106 |       await authenticate(req, res, next);\n      107 |\n    > 108 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      109 |         status: 401,\n      110 |         message: 'User not found'\n      111 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:108:20)\n\n  ● Auth Middleware › authenticate › should handle database errors\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Database error\", \"status\": 401}\n\n    Number of calls: 0\n\n      122 |       await authenticate(req, res, next);\n      123 |\n    > 124 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      125 |         status: 401,\n      126 |         message: 'Database error'\n      127 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:124:20)\n\n  ● Auth Middleware › authorize › should deny access for non-matching tier\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Insufficient subscription tier\", \"status\": 403}\n    Received: called with 0 arguments\n\n    Number of calls: 1\n\n      146 |       middleware(req, res, next);\n      147 |\n    > 148 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      149 |         status: 403,\n      150 |         message: 'Insufficient subscription tier'\n      151 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:148:20)\n\n  ● Auth Middleware › authorize › should handle missing user\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Insufficient subscription tier\", \"status\": 403}\n\n    Number of calls: 0\n\n      157 |       middleware(req, res, next);\n      158 |\n    > 159 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      160 |         status: 403,\n      161 |         message: 'Insufficient subscription tier'\n      162 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/middleware/auth.test.js:159:20)\n\n  ● Auth Middleware › validateApiKey › should validate correct API key\n\n    TypeError: validateApiKey is not a function\n\n      183 |       require('../../src/config/database').db.from.mockReturnValue(mockApiKey);\n      184 |\n    > 185 |       await validateApiKey(req, res, next);\n          |             ^\n      186 |\n      187 |       expect(req.apiKey).toEqual(expect.objectContaining({\n      188 |         id: 'key-123'\n\n      at Object.validateApiKey (tests/middleware/auth.test.js:185:13)\n\n  ● Auth Middleware › validateApiKey › should reject missing API key\n\n    TypeError: validateApiKey is not a function\n\n      192 |\n      193 |     it('should reject missing API key', async () => {\n    > 194 |       await validateApiKey(req, res, next);\n          |             ^\n      195 |\n      196 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n      197 |         status: 401,\n\n      at Object.validateApiKey (tests/middleware/auth.test.js:194:13)\n\n  ● Auth Middleware › validateApiKey › should reject invalid API key\n\n    TypeError: validateApiKey is not a function\n\n      214 |       require('../../src/config/database').db.from.mockReturnValue(mockApiKey);\n      215 |\n    > 216 |       await validateApiKey(req, res, next);\n          |             ^\n      217 |\n      218 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n      219 |         status: 401,\n\n      at Object.validateApiKey (tests/middleware/auth.test.js:216:13)\n\n  ● Auth Middleware › validateApiKey › should reject inactive API key\n\n    TypeError: validateApiKey is not a function\n\n      239 |       require('../../src/config/database').db.from.mockReturnValue(mockApiKey);\n      240 |\n    > 241 |       await validateApiKey(req, res, next);\n          |             ^\n      242 |\n      243 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n      244 |         status: 401,\n\n      at Object.validateApiKey (tests/middleware/auth.test.js:241:13)\n\n  ● Auth Middleware › tierRateLimit › should create tier-specific rate limiters\n\n    expect(received).toBeDefined()\n\n    Received: undefined\n\n      254 |       const professionalLimiter = tierRateLimit.professional;\n      255 |\n    > 256 |       expect(basicLimiter).toBeDefined();\n          |                            ^\n      257 |       expect(premiumLimiter).toBeDefined();\n      258 |       expect(professionalLimiter).toBeDefined();\n      259 |       expect(typeof basicLimiter).toBe('function');\n\n      at Object.toBeDefined (tests/middleware/auth.test.js:256:28)\n\nFAIL tests/controllers/authController.test.js\n  AuthController - Simple Tests\n    register\n      ✕ should handle registration errors gracefully (1 ms)\n      ✓ should handle unexpected errors\n    login\n      ✕ should handle invalid credentials (1 ms)\n    logout\n      ✕ should handle logout without token (1 ms)\n      ✕ should handle logout with token\n    changePassword\n      ✕ should handle password update errors\n    deleteAccount\n      ✓ should handle account deletion errors\n    refreshToken\n      ✕ should handle missing refresh token (1 ms)\n\n  ● AuthController - Simple Tests › register › should handle registration errors gracefully\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"User already exists\", \"status\": 400}\n    Received: [TypeError: Cannot read properties of undefined (reading 'isEmpty')]\n\n    Number of calls: 1\n\n      54 |       await authController.register(req, res, next);\n      55 |\n    > 56 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n         |                    ^\n      57 |         status: 400,\n      58 |         message: 'User already exists'\n      59 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:56:20)\n\n  ● AuthController - Simple Tests › login › should handle invalid credentials\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Invalid credentials\", \"status\": 401}\n    Received: [TypeError: Cannot read properties of undefined (reading 'isEmpty')]\n\n    Number of calls: 1\n\n      88 |       await authController.login(req, res, next);\n      89 |\n    > 90 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n         |                    ^\n      91 |         status: 401,\n      92 |         message: 'Invalid credentials'\n      93 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:90:20)\n\n  ● AuthController - Simple Tests › logout › should handle logout without token\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    - Expected\n    + Received\n\n      Object {\n    -   \"message\": \"Logged out successfully\",\n    +   \"message\": \"Logout successful\",\n      },\n\n    Number of calls: 1\n\n      101 |       await authController.logout(req, res, next);\n      102 |\n    > 103 |       expect(res.json).toHaveBeenCalledWith({\n          |                        ^\n      104 |         message: 'Logged out successfully'\n      105 |       });\n      106 |     });\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:103:24)\n\n  ● AuthController - Simple Tests › logout › should handle logout with token\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    - Expected\n    + Received\n\n      Object {\n    -   \"message\": \"Logged out successfully\",\n    +   \"message\": \"Logout successful\",\n      },\n\n    Number of calls: 1\n\n      112 |       await authController.logout(req, res, next);\n      113 |\n    > 114 |       expect(res.json).toHaveBeenCalledWith({\n          |                        ^\n      115 |         message: 'Logged out successfully'\n      116 |       });\n      117 |     });\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:114:24)\n\n  ● AuthController - Simple Tests › changePassword › should handle password update errors\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"status\": 400}\n    Received: [TypeError: Cannot read properties of undefined (reading 'isEmpty')]\n\n    Number of calls: 1\n\n      131 |       await authController.changePassword(req, res, next);\n      132 |\n    > 133 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      134 |         status: 400\n      135 |       }));\n      136 |     });\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:133:20)\n\n  ● AuthController - Simple Tests › refreshToken › should handle missing refresh token\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": \"Refresh token required\", \"status\": 400}\n\n    Number of calls: 0\n\n      159 |       await authController.refreshToken(req, res, next);\n      160 |\n    > 161 |       expect(next).toHaveBeenCalledWith(expect.objectContaining({\n          |                    ^\n      162 |         status: 400,\n      163 |         message: 'Refresh token required'\n      164 |       }));\n\n      at Object.toHaveBeenCalledWith (tests/controllers/authController.test.js:161:20)\n\nFAIL tests/middleware/rateLimiter.test.js\n  Rate Limiter Middleware\n    ✕ should export rate limiter functions (1 ms)\n    ✕ should create rate limiter with custom options\n    ✕ should create rate limiter with message function\n    ✕ should have different limits for different limiters (1 ms)\n    ✕ should handle skip function\n    ✕ should handle standardHeaders option\n\n  ● Rate Limiter Middleware › should export rate limiter functions\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: \"function\"\n    Received: \"undefined\"\n\n      4 |   it('should export rate limiter functions', () => {\n      5 |     expect(rateLimiter).toBeDefined();\n    > 6 |     expect(typeof rateLimiter.createRateLimiter).toBe('function');\n        |                                                  ^\n      7 |     expect(typeof rateLimiter.apiLimiter).toBe('function');\n      8 |     expect(typeof rateLimiter.authLimiter).toBe('function');\n      9 |   });\n\n      at Object.toBe (tests/middleware/rateLimiter.test.js:6:50)\n\n  ● Rate Limiter Middleware › should create rate limiter with custom options\n\n    TypeError: rateLimiter.createRateLimiter is not a function\n\n      10 |\n      11 |   it('should create rate limiter with custom options', () => {\n    > 12 |     const customLimiter = rateLimiter.createRateLimiter({\n         |                                       ^\n      13 |       windowMs: 5 * 60 * 1000,\n      14 |       max: 10\n      15 |     });\n\n      at Object.createRateLimiter (tests/middleware/rateLimiter.test.js:12:39)\n\n  ● Rate Limiter Middleware › should create rate limiter with message function\n\n    TypeError: rateLimiter.createRateLimiter is not a function\n\n      20 |\n      21 |   it('should create rate limiter with message function', () => {\n    > 22 |     const customLimiter = rateLimiter.createRateLimiter({\n         |                                       ^\n      23 |       windowMs: 1 * 60 * 1000,\n      24 |       max: 5,\n      25 |       message: (req, res) => {\n\n      at Object.createRateLimiter (tests/middleware/rateLimiter.test.js:22:39)\n\n  ● Rate Limiter Middleware › should have different limits for different limiters\n\n    expect(received).toBeDefined()\n\n    Received: undefined\n\n      33 |   it('should have different limits for different limiters', () => {\n      34 |     // API limiter와 Auth limiter는 다른 설정을 가져야 함\n    > 35 |     expect(rateLimiter.apiLimiter).toBeDefined();\n         |                                    ^\n      36 |     expect(rateLimiter.authLimiter).toBeDefined();\n      37 |     expect(rateLimiter.apiLimiter).not.toBe(rateLimiter.authLimiter);\n      38 |   });\n\n      at Object.toBeDefined (tests/middleware/rateLimiter.test.js:35:36)\n\n  ● Rate Limiter Middleware › should handle skip function\n\n    TypeError: rateLimiter.createRateLimiter is not a function\n\n      39 |\n      40 |   it('should handle skip function', () => {\n    > 41 |     const skipLimiter = rateLimiter.createRateLimiter({\n         |                                     ^\n      42 |       windowMs: 1 * 60 * 1000,\n      43 |       max: 5,\n      44 |       skip: (req) => req.ip === '127.0.0.1'\n\n      at Object.createRateLimiter (tests/middleware/rateLimiter.test.js:41:37)\n\n  ● Rate Limiter Middleware › should handle standardHeaders option\n\n    TypeError: rateLimiter.createRateLimiter is not a function\n\n      49 |\n      50 |   it('should handle standardHeaders option', () => {\n    > 51 |     const limiter = rateLimiter.createRateLimiter({\n         |                                 ^\n      52 |       windowMs: 1 * 60 * 1000,\n      53 |       max: 100,\n      54 |       standardHeaders: true,\n\n      at Object.createRateLimiter (tests/middleware/rateLimiter.test.js:51:33)\n\nFAIL tests/utils/logger.test.js\n  Logger Utility\n    ✕ should create logger instance (1 ms)\n    ✓ should have all log methods\n    ✕ should have correct log level in test environment (1 ms)\n    ✓ should log without errors\n    ✓ should handle log with metadata\n    ✓ should handle various log formats\n\n  ● Logger Utility › should create logger instance\n\n    expect(received).toBeDefined()\n\n    Received: undefined\n\n       5 |   it('should create logger instance', () => {\n       6 |     expect(logger).toBeDefined();\n    >  7 |     expect(logger.transports).toBeDefined();\n         |                               ^\n       8 |   });\n       9 |\n      10 |   it('should have all log methods', () => {\n\n      at Object.toBeDefined (tests/utils/logger.test.js:7:31)\n\n  ● Logger Utility › should have correct log level in test environment\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: \"silent\"\n    Received: undefined\n\n      17 |   it('should have correct log level in test environment', () => {\n      18 |     // 테스트 환경에서는 silent 레벨이어야 함\n    > 19 |     expect(logger.level).toBe('silent');\n         |                          ^\n      20 |   });\n      21 |\n      22 |   it('should log without errors', () => {\n\n      at Object.toBe (tests/utils/logger.test.js:19:26)\n\nFAIL tests/services/finnhubService.test.js\n  FinnhubService\n    constructor\n      ✕ should initialize with API key and cache\n    static methods\n      ✕ should format candles data correctly\n      ✕ should handle empty candles data\n      ✕ should handle missing candles data\n      ✕ should calculate period from date correctly\n      ✕ should handle invalid date for period calculation\n    cache operations\n      ✕ should check cache before making API call\n      ✕ should set cache with TTL\n    error handling\n      ✕ should handle missing API key\n    helper methods\n      ✕ should build correct URL with parameters\n\n  ● FinnhubService › constructor › should initialize with API key and cache\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › static methods › should format candles data correctly\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › static methods › should handle empty candles data\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › static methods › should handle missing candles data\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › static methods › should calculate period from date correctly\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › static methods › should handle invalid date for period calculation\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › cache operations › should check cache before making API call\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › cache operations › should set cache with TTL\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › error handling › should handle missing API key\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\n  ● FinnhubService › helper methods › should build correct URL with parameters\n\n    TypeError: FinnhubService is not a constructor\n\n      18 |     NodeCache.mockImplementation(() => mockCache);\n      19 |     \n    > 20 |     service = new FinnhubService();\n         |               ^\n      21 |   });\n      22 |\n      23 |   afterEach(() => {\n\n      at Object.<anonymous> (tests/services/finnhubService.test.js:20:15)\n\nFAIL tests/middleware/errorHandler.test.js\n  Error Handler Middleware\n    ✕ should handle 400 validation error (1 ms)\n    ✕ should handle 401 unauthorized error\n    ✕ should handle 404 not found error\n    ✕ should handle 500 server error\n    ✕ should include details if provided\n    ✕ should include stack trace in development\n    ✕ should handle error without message\n    ✕ should handle non-Error objects\n\n  ● Error Handler Middleware › should handle 400 validation error\n\n    TypeError: errorHandler is not a function\n\n      17 |     error.status = 400;\n      18 |\n    > 19 |     errorHandler(error, req, res, next);\n         |     ^\n      20 |\n      21 |     expect(res.status).toHaveBeenCalledWith(400);\n      22 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:19:5)\n\n  ● Error Handler Middleware › should handle 401 unauthorized error\n\n    TypeError: errorHandler is not a function\n\n      30 |     error.status = 401;\n      31 |\n    > 32 |     errorHandler(error, req, res, next);\n         |     ^\n      33 |\n      34 |     expect(res.status).toHaveBeenCalledWith(401);\n      35 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:32:5)\n\n  ● Error Handler Middleware › should handle 404 not found error\n\n    TypeError: errorHandler is not a function\n\n      43 |     error.status = 404;\n      44 |\n    > 45 |     errorHandler(error, req, res, next);\n         |     ^\n      46 |\n      47 |     expect(res.status).toHaveBeenCalledWith(404);\n      48 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:45:5)\n\n  ● Error Handler Middleware › should handle 500 server error\n\n    TypeError: errorHandler is not a function\n\n      56 |     // No status means 500\n      57 |\n    > 58 |     errorHandler(error, req, res, next);\n         |     ^\n      59 |\n      60 |     expect(res.status).toHaveBeenCalledWith(500);\n      61 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:58:5)\n\n  ● Error Handler Middleware › should include details if provided\n\n    TypeError: errorHandler is not a function\n\n      70 |     error.details = { field: 'email', message: 'Invalid format' };\n      71 |\n    > 72 |     errorHandler(error, req, res, next);\n         |     ^\n      73 |\n      74 |     expect(res.json).toHaveBeenCalledWith({\n      75 |       error: 'Bad Request',\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:72:5)\n\n  ● Error Handler Middleware › should include stack trace in development\n\n    TypeError: errorHandler is not a function\n\n      85 |     error.stack = 'Error: Dev Error\\n    at test.js:10:5';\n      86 |\n    > 87 |     errorHandler(error, req, res, next);\n         |     ^\n      88 |\n      89 |     expect(res.json).toHaveBeenCalledWith({\n      90 |       error: 'Internal server error',\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:87:5)\n\n  ● Error Handler Middleware › should handle error without message\n\n    TypeError: errorHandler is not a function\n\n      100 |     error.status = 403;\n      101 |\n    > 102 |     errorHandler(error, req, res, next);\n          |     ^\n      103 |\n      104 |     expect(res.status).toHaveBeenCalledWith(403);\n      105 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:102:5)\n\n  ● Error Handler Middleware › should handle non-Error objects\n\n    TypeError: errorHandler is not a function\n\n      112 |     const error = { message: 'Custom error', code: 'CUSTOM_ERROR' };\n      113 |\n    > 114 |     errorHandler(error, req, res, next);\n          |     ^\n      115 |\n      116 |     expect(res.status).toHaveBeenCalledWith(500);\n      117 |     expect(res.json).toHaveBeenCalledWith({\n\n      at Object.errorHandler (tests/middleware/errorHandler.test.js:114:5)\n\nFAIL tests/validators/validators.test.js\n  ● Test suite failed to run\n\n    TypeError: body is not a function\n\n      2 |\n      3 | const validateRegister = [\n    > 4 |   body('email')\n        |   ^\n      5 |     .isEmail()\n      6 |     .normalizeEmail()\n      7 |     .withMessage('Please provide a valid email'),\n\n      at Object.body (src/validators/auth.js:4:3)\n      at Object.<anonymous> (tests/validators/validators.test.js:1:60)\n\nJest: \"global\" coverage threshold for statements (60%) not met: 15.94%\nJest: \"global\" coverage threshold for branches (50%) not met: 6.66%\nJest: \"global\" coverage threshold for lines (60%) not met: 16.97%\nJest: \"global\" coverage threshold for functions (50%) not met: 13.18%\nTest Suites: 8 failed, 8 total\nTests:       51 failed, 7 passed, 58 total\nSnapshots:   0 total\nTime:        0.617 s, estimated 1 s\nRan all test suites.\nTest results written to: coverage-report.json\n"
    }
  ],
  "passed": false
}